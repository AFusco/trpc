---
id: quickstart
title: Quickstart
sidebar_label: Quickstart
slug: /quickstart
description: Learn how to quickly get started and setup tRPC
---

import CodeBlock from '@theme/CodeBlock';
import TabItem from '@theme/TabItem';
import Tabs from '@theme/Tabs';

:::tip
We highly encourage you to check out [the example apps](example-apps.mdx) to learn about how tRPC is installed in your favorite framework.
:::

<!-- Reusable snippet for a full backend -->

```twoslash include server
import { initTRPC } from '@trpc/server';
import { createHTTPServer } from "@trpc/server/adapters/standalone";
import { z } from "zod";

const t = initTRPC.create();

const router = t.router;
const publicProcedure = t.procedure;

type User = { id: string; name: string };
const db = {} as {
  user: {
    findMany: () => Promise<User[]>;
    findById: (id: string) => Promise<User>;
    create: (data: { name: string }) => Promise<User>;
  };
};

const appRouter = router({
    userList: t.procedure.query(async () => {
    const users = await db.user.findMany();
    return users;
  }),
  userById: t.procedure.input(z.string()).query(async (opts) => {
    const { input } = opts;
    const user = await db.user.findById(input);
    return user;
  }),
  userCreate: publicProcedure
    .input(z.object({ name: z.string() }))
    .mutation(async (opts) => {
      const { input } = opts;
      const user = await db.user.create(input);
      return user;
    }),
});

export type AppRouter = typeof appRouter;

const server = createHTTPServer({
  router: appRouter,
});

server.listen(3000);
```

<!-- End reusable snippet for a full backend -->

## Installation

tRPC is broken up into several packages, so you can install only what you need. Make sure to install the packages you want in the proper sections of your codebase.

:::info Requirements

- tRPC requires TypeScript >= 4.7.0
- We strongly recommend you using `"strict": true` in your `tsconfig.json` as we don't officially support non-strict mode.

:::

<table width="100%">
  <thead>
    <tr>
      <th>Purpose</th>
      <th>Location</th>
      <th>Install command</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Implement endpoints and routers</td>
      <td>Server</td>
      <td>
        <code>npm install @trpc/server</code>
      </td>
    </tr>
    <tr>
      <td>Call procedures on client</td>
      <td>Client</td>
      <td>
        <code>npm install @trpc/client @trpc/server</code>
      </td>
    </tr>
    <tr>
      <td>
        React hooks powered by{' '}
        <a
          href="https://tanstack.com/query/v4/docs/adapters/react-query"
          target="_blank"
          rel="noopener noreferrer"
        >
          @tanstack/react-query
        </a>{' '}
      </td>
      <td>Client</td>
      <td>
        <code>npm install @trpc/react-query @tanstack/react-query @trpc/client @trpc/server</code>
      </td>
      </tr>
      <tr>
      <td>
        Next.js integration utilities </td>
      <td>Next.js</td>
      <td>
        <code>npm install next @trpc/next @trpc/react-query @tanstack/react-query @trpc/client @trpc/server</code>
      </td>
    </tr>

  </tbody>
</table>

### Installation Snippets

Here are some install scripts to add tRPC to your project. These scripts include every `@trpc/*` package, so feel free to remove what you don't need!

<Tabs>
  <TabItem value="npm" label="npm" default>

```sh
npm install @trpc/server @trpc/client @trpc/react-query @trpc/next @tanstack/react-query
```

  </TabItem>
  <TabItem value="yarn" label="yarn">

```sh
yarn add @trpc/server @trpc/client @trpc/react-query @trpc/next @tanstack/react-query
```

  </TabItem>
  <TabItem value="pnpm" label="pnpm">

```sh
pnpm add @trpc/server @trpc/client @trpc/react-query @trpc/next @tanstack/react-query
```

  </TabItem>
</Tabs>

## Defining a backend router

Let's walk through the steps of building a typesafe API with tRPC. To start, this API will contain three endpoints with these TypeScript signatures:

```ts
type User = { id: string; name: string; };

userList() => User[];
userById(id: string) => User;
userCreate(data: { name: string }) => User;
```

### 1. Create a router instance

First, let's initilize the tRPC backend and define an empty router in our server codebase:

```ts twoslash title='server.ts'
import { initTRPC } from '@trpc/server';

const t = initTRPC.create();

const router = t.router;
const publicProcedure = t.procedure;

const appRouter = router({});

// Export type router type signature,
// NOT the router itself.
export type AppRouter = typeof appRouter;
```

### 2. Add a query procedure

Use `publicProcedure.query()` to add a query procedure to the router.

:::info

Query procedures are the equivalent of a GET endpoint in a REST-based API.

:::

The following creates a query procedure called `userList` that returns a list of users from our database:

```twoslash include setup
import { initTRPC } from '@trpc/server';

const t = initTRPC.create();

const router = t.router;
const publicProcedure = t.procedure;

type User = { id: string; name: string };
const db = {} as {
  user: {
    findMany: () => Promise<User[]>;
    findById: (id: string) => Promise<User>;
    create: (data: { name: string }) => Promise<User>;
  };
};
```

```ts twoslash title='server.ts'
// @include: setup

// ---cut---

const appRouter = t.router({
  userList: t.procedure.query(async () => {
    // Retrieve users from a datasource, this is an imaginary database
    const users = await db.user.findMany();
    //    ^?
    return users;
  }),
});
```

### 3. Using input parser to validate procedure inputs

To implement the `userById` procedure, we need to accept input from the client. tRPC lets you define [input parsers](/docs/server/input-parsers) to validate and parse the input. You can define your own input parser or use a validation library of your choice, like [zod](https://zod.dev), [yup](https://yup.dev), or [superstruct](https://superstruct.dev).

You define your input parser on `publicProcedure.input()`, which can then be accessed on the resolver function as shown below:

<Tabs>
  <TabItem value="vanilla" label="Vanilla" default>
     The input parser should be a function that validates and casts the input of this procedure. It should return a strongly typed value when the input is valid or throw an error if the input is invalid.

<br />
<br />

```ts twoslash title='server.ts'
// @include: setup
// ---cut---
const appRouter = t.router({
  // ...
  userById: t.procedure
    // The input is unknown at this time. A client could have sent
    // us anything so we won't assume a certain data type.
    .input((val: unknown) => {
      // If the value is of type string, return it.
      // It will now be inferred as string.
      if (typeof val === 'string') return val;

      // Uh oh, looks like that input wasn't a string.
      // We will throw an error instead of running the procedure.
      throw new Error(`Invalid input: ${typeof val}`);
    })
    .query(async (opts) => {
      const { input } = opts;
      //      ^?
      // Retrieve the user with the given ID
      const user = await db.user.findById(input);
      //    ^?
      return user;
    }),
});
```

  </TabItem>
  <TabItem value="zod" label="Zod">
    The input parser can be any <code>ZodType</code>, e.g. <code>z.string()</code> or <code>z.object({})</code>.

<br />
<br />

```ts twoslash title='server.ts'
// @include: setup
// ---cut---
import { z } from 'zod';

const appRouter = t.router({
  // ...
  userById: t.procedure.input(z.string()).query(async (opts) => {
    const { input } = opts;
    //      ^?
    // Retrieve the user with the given ID
    const user = await db.user.findById(input);
    //    ^?
    return user;
  }),
});
```

</TabItem>
  <TabItem value="yup" label="Yup">
    The input parser can be any <code>YupSchema</code>, e.g. <code>yup.string()</code> or <code>yup.object({})</code>.

<br />
<br />

```ts twoslash title='server.ts'
// @include: setup
// ---cut---
import * as yup from 'yup';

const appRouter = t.router({
  // ...
  userById: t.procedure.input(yup.string().required()).query(async (opts) => {
    const { input } = opts;
    //      ^?
    // Retrieve the user with the given ID
    const user = await db.user.findById(input);
    //    ^?
    return user;
  }),
});
```

  </TabItem>
</Tabs>

:::info

Throughout the remaining of this documentation, we will use `zod` as our validation library.

:::

### 4. Adding a mutation procedure

Similar to GraphQL, tRPC makes a distinction between query and mutation procedures.

The way a procedure works on the server doesn't change much between a query and a mutation. The method name is different, and the way that the client will use this procedure changes - but everything else is the same!

Let's add a `userCreate` mutation by adding it as a new property on our router object:

```ts twoslash title='server.ts'
// @include: setup
// ---cut---
import { z } from 'zod';

const appRouter = t.router({
  // ...
  userCreate: t.procedure
    .input(z.object({ name: z.string() }))
    .mutation(async (opts) => {
      const { input } = opts;
      //      ^?
      // Create a new user in the database
      const user = await db.user.create(input);
      //    ^?
      return user;
    }),
});
```

## Serving the API

Now that we have defined our router, we can serve it. tRPC has many [adapters](/docs/server/adapters) so you can use any backend framework of your choice. To keep it simple, we'll use the [`standalone`](/docs/server/adapters/standalone) adapter.

<!--  prettier-ignore-start -->
```ts twoslash title='server.ts'
// @include: setup
const appRouter = t.router({
  // ...
});
// ---cut---

import { createHTTPServer } from '@trpc/server/adapters/standalone';

const server = createHTTPServer({
  router: appRouter,
});

server.listen(3000);
```
<!-- prettier-ignore-end -->

<details>
<summary>See the full backend code</summary>

```ts twoslash title='server.ts'
// @include: server
```

</details>

## Using your new backend on the client

Let's now move to your frontend code and embrace the power of end-to-end typesafety. When we import the `AppRouter` type for the client to use, we have achieved full typesafety for our system without leaking any implementation details to the client.

### 1. Setup the tRPC Client

```ts twoslash title="client.ts"
// @target: esnext
// @filename: server.ts
// @include: server
// @filename: client.ts
// ---cut---
import { createTRPCProxyClient, httpBatchLink } from '@trpc/client';
import type { AppRouter } from './server';

// Notice the <AppRouter> generic here.
const trpc = createTRPCProxyClient<AppRouter>({
  links: [
    httpBatchLink({
      url: 'http://localhost:3000/trpc',
    }),
  ],
});
```

### 2. Querying & mutating

You now have access to your API procedures on the `trpc` object. Try it out!

```ts twoslash title="client.ts"
// @target: esnext
// @filename: server.ts
// @include: server
// @filename: client.ts
import { createTRPCProxyClient, httpBatchLink } from '@trpc/client';
import type { AppRouter } from './server';

const trpc = createTRPCProxyClient<AppRouter>({
  links: [
    httpBatchLink({
      url: 'http://localhost:3000',
    }),
  ],
});

// ---cut---
// Inferred types
const user = await trpc.userById.query('1');
//    ^?

const createdUser = await trpc.userCreate.mutate({ name: 'sachinraja' });
//    ^?
```

### Full autocompletion

You can open up your Intellisense to explore your API on your frontend. You'll find all of your procedure routes waiting for you along with the methods for calling them.

```ts twoslash title="client.ts"
// @target: esnext
// @filename: server.ts
// @include: server
// @filename: client.ts
import { createTRPCProxyClient, httpBatchLink } from '@trpc/client';
import type { AppRouter } from './server';

const trpc = createTRPCProxyClient<AppRouter>({
  links: [
    httpBatchLink({
      url: 'http://localhost:3000',
    }),
  ],
});

// ---cut---
// @errors: 2339
// Full autocompletion on your routes
trpc.u;
//    ^|
```

## Try it out for yourself!

import { Iframe } from '@site/src/components/Iframe';
import { searchParams } from '@site/src/utils/searchParams';
import clsx from 'clsx';

<div
  className={clsx(
    'h-[800px] w-full rounded-xl overflow-hidden z-10 relative my-0 md:my-4 lg:my-8',
  )}
>
  <Iframe
    src={
      `https://stackblitz.com/github/trpc/trpc/tree/quickstart/examples/quickstart?` +
      searchParams({
        embed: '1',
        file: [
          // Opens these side-by-side
          'client/index.ts',
          'server/index.ts',
        ],
        hideNavigation: '1',
        terminalHeight: '1',
        showSidebar: '0',
        view: 'editor',
      })
    }
    frameBorder="0"
  />
</div>

## Next steps

:::tip
By default, tRPC will map complex types like `Date` to their JSON-equivalent _(`string` in the case of `Date`)_. If you want to add to retain the integrity of those types, the easiest way to add support for these is to [use superjson](/docs/server/data-transformers#using-superjson) as a Data Transformer.
:::

tRPC includes more sophisticated client-side tooling designed for React projects and Next.js.

- [Usage with Next.js](/docs/nextjs/introduction)
- [Usage with Express (server-side)](/docs/server/adapters/express)
- [Usage with React (client-side)](/docs/reactjs/introduction)
